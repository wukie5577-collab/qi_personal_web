<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qi Wu | VR &amp; AI Researcher – Cyber VR</title>
    <style>
        /*
            Base styles stay close to the original design but add subtle
            enhancements and new controls. The dark canvas and neon accents
            evoke a VR/cyber‑punk feel. Interactive controls live inside
            the content area and are fully responsive.
        */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000005;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: white;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* Layout container: left/right split */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            display: flex;
            align-items: center;
            pointer-events: none; /* allow pointer events to fall through except on controls */
        }

        /* Left content area */
        .content-area {
            width: 45%;
            padding-left: 8%;
            pointer-events: auto; /* enable interaction on controls within */
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .card {
            background: rgba(10, 10, 20, 0.4);
            backdrop-filter: blur(8px);
            padding: 2.5rem;
            border-left: 2px solid rgba(255, 255, 255, 0.1);
            transition: all 0.5s cubic-bezier(0.19, 1, 0.22, 1);
            position: relative;
            overflow: hidden;
        }

        /* Decorative scanning line on the card */
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: #00ffff;
            transform: scaleY(0);
            transform-origin: bottom;
            transition: transform 0.5s ease;
            box-shadow: 0 0 20px #00ffff;
        }

        .card:hover {
            background: rgba(10, 10, 20, 0.6);
            transform: translateX(10px);
        }

        .card:hover::before {
            transform: scaleY(1);
            transform-origin: top;
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 700;
            margin: 0;
            background: linear-gradient(90deg, #ffffff, #88ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -2px;
        }

        h2 {
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #5f7e97;
            margin-top: 10px;
            margin-bottom: 30px;
        }

        p {
            font-size: 1rem;
            line-height: 1.6;
            color: #a0aab5;
            max-width: 500px;
            margin-bottom: 1rem;
        }

        .highlight {
            color: #42d3ff;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(66, 211, 255, 0.3);
        }

        /* Stats bar design */
        .stats {
            margin-top: 2rem;
            display: flex;
            gap: 2rem;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            cursor: pointer;
        }

        .stat-item:hover .stat-val {
            color: #00ffff;
        }

        .stat-val {
            font-size: 1.5rem;
            font-weight: 700;
            color: white;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #5f7e97;
            text-transform: uppercase;
        }

        /* Control panel: slider and glitch toggle */
        .controls {
            margin-top: 2rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        label {
            font-size: 0.8rem;
            color: #5f7e97;
            text-transform: uppercase;
        }

        #expansion-slider {
            -webkit-appearance: none;
            width: 150px;
            height: 4px;
            background: rgba(66, 211, 255, 0.3);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        #expansion-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #42d3ff;
            box-shadow: 0 0 10px rgba(66, 211, 255, 0.6);
            transition: transform 0.3s ease;
        }

        #expansion-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        #expansion-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #42d3ff;
            box-shadow: 0 0 10px rgba(66, 211, 255, 0.6);
        }

        #glitch-toggle {
            background: rgba(10, 10, 20, 0.6);
            border: 1px solid #00ffff;
            color: #42d3ff;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.3s ease, color 0.3s ease;
            pointer-events: auto;
        }

        #glitch-toggle:hover {
            background: rgba(0, 50, 100, 0.8);
            color: #00ffff;
            transform: translateY(-2px);
        }

        /* Responsive: mobile stack layout */
        @media (max-width: 768px) {
            .content-area {
                width: 100%;
                padding: 2rem;
                padding-top: 50vh; /* push content down to leave space for 3D on top */
                background: linear-gradient(to top, #000005 20%, transparent);
            }
            .card {
                background: none;
                backdrop-filter: none;
                border: none;
                padding: 0;
            }
            h1 { font-size: 2.5rem; }
            .controls {
                margin-top: 1rem;
            }
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="content-area">
            <div class="card" id="active-card">
                <h1>Qi Wu</h1>
                <h2>Architect of Reality</h2>
                
                <p>
                    I teach machines to understand human balance.
                    Focusing on <span class="highlight">VR Cybersickness Mitigation</span> through Deep Learning and immersion evaluation.
                </p>
                <p>
                    Currently optimizing the sensory loop at <strong>IMT Atlantique</strong>.
                </p>

                <div class="stats">
                    <div class="stat-item" data-skill="unity">
                        <span class="stat-val">Unity</span>
                        <span class="stat-label">Core Engine</span>
                    </div>
                    <div class="stat-item" data-skill="pytorch">
                        <span class="stat-val">PyTorch</span>
                        <span class="stat-label">Neural Nets</span>
                    </div>
                    <div class="stat-item" data-skill="spatial">
                        <span class="stat-val">Spatial</span>
                        <span class="stat-label">Audio &amp; UX</span>
                    </div>
                </div>

                <!-- Interactive controls for the 3D scene -->
                <div class="controls">
                    <label for="expansion-slider">Chaos&nbsp;to&nbsp;Order</label>
                    <input type="range" id="expansion-slider" min="0" max="1" step="0.01" value="1">
                    <button id="glitch-toggle">Enable Glitch</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Core Three.js library and postprocessing scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Pass base class required by certain postprocessing passes -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- Additional postprocessing: Afterimage and Glitch -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/AfterimagePass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/DigitalGlitch.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/GlitchPass.js"></script>

    <script>
        // Core variables
        let scene, camera, renderer, composer;
        let mainGroup; // group containing all 3D objects
        let particles, wireframeMesh, coreSphere;
        let afterimagePass, glitchPass;
        let starField; // distant star field for background

        // Interaction state
        let isCardHovered = false;
        let mouseX = 0;
        let mouseY = 0;

        // Animation parameters
        let expansionFactor = 1.0; // 1 = exploded (chaos), 0 = ordered (cohesion)
        let userSliderExpansion = 1.0; // value from slider (0-1)
        let useGlitch = false; // glitch state

        // Colors for highlighting skills
        const defaultColors = {
            particles: new THREE.Color(0x42d3ff),
            sphere: new THREE.Color(0x00ffff),
            wireframe: new THREE.Color(0x2244aa)
        };
        const skillColors = {
            unity: new THREE.Color(0xff8c00),    // vibrant orange for Unity
            pytorch: new THREE.Color(0xee4c2c),  // PyTorch orange-red
            spatial: new THREE.Color(0x00ff88)   // neon green for spatial audio
        };

        init();
        animate();

        function init() {
            // (debug overlay removed in production)

            // 1. Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000005, 0.02);

            // 2. Camera (offset left to leave space for text)
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 25;
            camera.position.x = -5;

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. Object group (positioned to the right)
            mainGroup = new THREE.Group();
            mainGroup.position.x = 8;
            scene.add(mainGroup);

            // A. Core sphere (stable state)
            const sphereGeo = new THREE.IcosahedronGeometry(4, 1);
            const sphereMat = new THREE.MeshBasicMaterial({
                color: defaultColors.sphere,
                wireframe: true,
                transparent: true,
                opacity: 0.1
            });
            coreSphere = new THREE.Mesh(sphereGeo, sphereMat);
            mainGroup.add(coreSphere);

            // B. Particle cloud (data points)
            const pGeo = new THREE.BufferGeometry();
            const pCount = 3000;
            const pPos = new Float32Array(pCount * 3);
            const pTarget = new Float32Array(pCount * 3);
            const pRandom = new Float32Array(pCount * 3);

            const tempGeo = new THREE.IcosahedronGeometry(4, 4);
            const targetPositions = tempGeo.attributes.position.array;

            for (let i = 0; i < pCount; i++) {
                const index = i % (targetPositions.length / 3);
                // target positions: evenly distributed on sphere surface with slight noise
                pTarget[i * 3] = targetPositions[index * 3] + (Math.random() - 0.5) * 0.5;
                pTarget[i * 3 + 1] = targetPositions[index * 3 + 1] + (Math.random() - 0.5) * 0.5;
                pTarget[i * 3 + 2] = targetPositions[index * 3 + 2] + (Math.random() - 0.5) * 0.5;

                // random positions: spread out in space
                pRandom[i * 3] = (Math.random() - 0.5) * 30;
                pRandom[i * 3 + 1] = (Math.random() - 0.5) * 30;
                pRandom[i * 3 + 2] = (Math.random() - 0.5) * 30;

                // initial position set to random
                pPos[i * 3] = pRandom[i * 3];
                pPos[i * 3 + 1] = pRandom[i * 3 + 1];
                pPos[i * 3 + 2] = pRandom[i * 3 + 2];
            }

            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            pGeo.setAttribute('targetPos', new THREE.BufferAttribute(pTarget, 3));
            pGeo.setAttribute('randomPos', new THREE.BufferAttribute(pRandom, 3));

            const pMat = new THREE.PointsMaterial({
                size: 0.15,
                color: defaultColors.particles,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            particles = new THREE.Points(pGeo, pMat);
            mainGroup.add(particles);

            // C. Outer wireframe
            const wireGeo = new THREE.IcosahedronGeometry(5.5, 1);
            const wireMat = new THREE.MeshBasicMaterial({
                color: defaultColors.wireframe,
                wireframe: true,
                transparent: true,
                opacity: 0.05
            });
            wireframeMesh = new THREE.Mesh(wireGeo, wireMat);
            mainGroup.add(wireframeMesh);

            // Add a distant star field for depth and immersion
            const starGeo = new THREE.BufferGeometry();
            const starCount = 800;
            const starPos = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                starPos[i * 3] = (Math.random() - 0.5) * 200;
                starPos[i * 3 + 1] = (Math.random() - 0.5) * 200;
                starPos[i * 3 + 2] = (Math.random() - 0.5) * 200;
            }
            starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
            const starMat = new THREE.PointsMaterial({ size: 0.3, color: 0x112244, transparent: true, opacity: 0.15 });
            starField = new THREE.Points(starGeo, starMat);
            scene.add(starField);

            // (debug cube removed)

            // 5. Post-processing passes
            // 5. Post-processing passes: render + bloom
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.5;
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            // Add GlitchPass for occasional glitch effect
            glitchPass = new THREE.GlitchPass();
            glitchPass.goWild = false;
            glitchPass.enabled = false; // start with glitch disabled
            glitchPass.renderToScreen = true;
            composer.addPass(glitchPass);

            // 6. Event listeners
            const card = document.getElementById('active-card');
            card.addEventListener('mouseenter', () => isCardHovered = true);
            card.addEventListener('mouseleave', () => isCardHovered = false);

            document.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX / window.innerWidth) * 2 - 1;
                mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            window.addEventListener('resize', onWindowResize);
            onWindowResize(); // initial placement

            // Slider control for expansion factor
            const slider = document.getElementById('expansion-slider');
            slider.addEventListener('input', (e) => {
                userSliderExpansion = parseFloat(e.target.value);
            });

            // Glitch toggle button
            const glitchToggle = document.getElementById('glitch-toggle');
            glitchToggle.addEventListener('click', () => {
                useGlitch = !useGlitch;
                // update glitch pass if it exists
                if (typeof glitchPass !== 'undefined' && glitchPass) {
                    glitchPass.enabled = useGlitch;
                    // optional: go wild when enabled for more intense glitch
                    glitchPass.goWild = useGlitch;
                }
                glitchToggle.textContent = useGlitch ? 'Disable Glitch' : 'Enable Glitch';
            });

            // Skill hover events
            document.querySelectorAll('.stat-item').forEach((item) => {
                item.addEventListener('mouseenter', () => {
                    const skill = item.dataset.skill;
                    highlightSkill(skill);
                });
                item.addEventListener('mouseleave', () => {
                    resetSkillHighlight();
                });
            });

            // expose renderer globally for VR button module
            window.renderer = renderer;
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // only update composer size if composer is defined (post-processing enabled)
            if (typeof composer !== 'undefined' && composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }

            // responsive positioning
            if (window.innerWidth < 768) {
                mainGroup.position.set(0, 2, 0);
                mainGroup.scale.set(0.7, 0.7, 0.7);
                camera.position.x = 0;
            } else {
                mainGroup.position.set(8, 0, 0);
                mainGroup.scale.set(1, 1, 1);
                camera.position.x = -5;
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            // (debug overlay removed)

            // 1. Determine target expansion: card hover overrides slider
            const targetExpansion = isCardHovered ? 0 : userSliderExpansion;
            expansionFactor += (targetExpansion - expansionFactor) * 0.03; // smooth interpolation

            // 2. Particle morphing
            const positions = particles.geometry.attributes.position.array;
            const targets = particles.geometry.attributes.targetPos.array;
            const randoms = particles.geometry.attributes.randomPos.array;

            for (let i = 0; i < positions.length; i += 3) {
                const tx = targets[i];
                const ty = targets[i + 1];
                const tz = targets[i + 2];
                const rx = randoms[i];
                const ry = randoms[i + 1];
                const rz = randoms[i + 2];

                // interpolate between random and target based on expansion factor
                const cx = tx + (rx - tx) * expansionFactor;
                const cy = ty + (ry - ty) * expansionFactor;
                const cz = tz + (rz - tz) * expansionFactor;

                // add subtle breathing motion (more noticeable in chaos)
                const noise = Math.sin(time * 2 + i) * 0.2 * expansionFactor;

                positions[i] += (cx - positions[i] + noise) * 0.1;
                positions[i + 1] += (cy - positions[i + 1] + noise) * 0.1;
                positions[i + 2] += (cz - positions[i + 2] + noise) * 0.1;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // 3. Overall rotation and parallax
            const rotSpeed = 0.001 + (1 - expansionFactor) * 0.005;
            mainGroup.rotation.y += rotSpeed;
            mainGroup.rotation.x += rotSpeed * 0.5;

            // mouse parallax
            mainGroup.rotation.y += mouseX * 0.05;
            mainGroup.rotation.x += mouseY * 0.05;

            // Rotate star field slowly for subtle motion
            if (typeof starField !== 'undefined' && starField) {
                starField.rotation.y += 0.0002;
                starField.rotation.x += 0.0001;
            }

            // 4. Wireframe opacity and breathing
            wireframeMesh.material.opacity = (1 - expansionFactor) * 0.15;
            wireframeMesh.scale.setScalar(1 + Math.sin(time) * 0.05);
            coreSphere.rotation.y -= 0.02;

            // Render the scene via composer (basic postprocessing)
            composer.render();
        }

        function highlightSkill(skill) {
            const color = skillColors[skill];
            if (!color) return;
            particles.material.color = color.clone();
            coreSphere.material.color = color.clone();
            wireframeMesh.material.color = color.clone();
        }

        function resetSkillHighlight() {
            particles.material.color = defaultColors.particles.clone();
            coreSphere.material.color = defaultColors.sphere.clone();
            wireframeMesh.material.color = defaultColors.wireframe.clone();
        }
    </script>

    <!-- VRButton removed to avoid 'VR not supported' message -->
</body>
</html>